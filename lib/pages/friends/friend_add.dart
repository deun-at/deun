import 'package:deun/helper/helper.dart';
import 'package:deun/main.dart';
import 'package:deun/pages/friends/friendship_model.dart';
import 'package:deun/pages/users/user_model.dart';
import 'package:deun/widgets/rounded_container.dart';
// Generated by Copilot - Removed unused shimmer import
import 'package:flutter/material.dart';
import 'package:deun/l10n/app_localizations.dart';
import 'package:flutter_contacts/flutter_contacts.dart' as fc;
import 'package:deun/pages/friends/widgets/requested_friendship_list.dart';
import 'package:deun/pages/friends/widgets/search_result_list.dart'; // Generated by Copilot
import 'package:deun/pages/friends/widgets/pending_request_list.dart'; // Generated by Copilot
import 'package:deun/pages/friends/widgets/contact_suggestion_list.dart'; // Generated by Copilot
import 'package:flutter/foundation.dart'; // Generated by Copilot - Import for compute

// Generated by Copilot - Top-level function for contact processing in an isolate
Future<List<User>> _findContactMatches(Map<String, dynamic> params) async {
  // Generated by Copilot
  final List<fc.Contact> contacts = params['contacts'];
  final Map<String, User> availableUserMap = params['availableUserMap'];
  final String searchText = params['searchText'].toLowerCase(); // Generated by Copilot - Lowercase search text once
  List<User> matchedUsers = [];

  for (var contact in contacts) {
    // Generated by Copilot - Check name or any email against search text
    bool nameMatches = contact.displayName.toLowerCase().contains(searchText);
    bool emailMatches = contact.emails.any((email) => email.address.toLowerCase().contains(searchText));

    // Generated by Copilot - Continue if search text is not empty and neither name nor email matches
    if (searchText.isNotEmpty && !nameMatches && !emailMatches) {
      continue;
    }

    User? matchedUser;
    for (var email in contact.emails) {
      final lowerCaseEmail = email.address.toLowerCase();
      if (availableUserMap.containsKey(lowerCaseEmail)) {
        matchedUser = availableUserMap[lowerCaseEmail];
        break;
      }
    }

    if (matchedUser != null) {
      matchedUsers.add(matchedUser);
    }
  }
  // Remove duplicates before returning
  return matchedUsers.toSet().toList(); // Generated by Copilot
}

class FriendAddBottomSheet extends StatefulWidget {
  const FriendAddBottomSheet({super.key});

  @override
  State<FriendAddBottomSheet> createState() => _FriendAddBottomSheetState();
}

class _FriendAddBottomSheetState extends State<FriendAddBottomSheet> {
  String _searchText = '';
  late Future<List<Friendship>> _currentFriendshipFuture;
  List<fc.Contact>? _cachedContacts; // Generated by Copilot - State variable to cache contacts

  @override
  void initState() {
    super.initState();
    _currentFriendshipFuture = _requestedFriendshipFuture();
  }

  Future<List<Friendship>> _requestedFriendshipFuture() async {
    return Friendship.getRequestedFriendships();
  }

  @override
  Widget build(BuildContext context) {
    // Generated by Copilot - Call the new functions to get the futures
    final userSearchFuture = _fetchUserSearchResults();
    final userPendingFuture = _fetchPendingFriendRequests();
    final userContactFuture = _fetchContactSuggestions();
    final userRequestedFuture = _fetchRequestedUsers();

    return DraggableScrollableSheet(
      expand: false,
      initialChildSize: 1,
      snap: true,
      builder: (context, scrollController) {
        return RoundedContainer(
          child: ScaffoldMessenger(
            key: friendAddScaffoldMessengerKey,
            child: Scaffold(
              appBar: AppBar(
                title: Text(AppLocalizations.of(context)!.addFriends),
                centerTitle: true,
              ),
              body: Container(
                color: Theme.of(context).colorScheme.surface,
                child: CustomScrollView(
                  controller: scrollController,
                  slivers: [
                    SliverToBoxAdapter(
                      child: Padding(
                        padding: const EdgeInsets.only(left: 8.0, right: 8.0),
                        child: SearchBar(
                          elevation: WidgetStateProperty.all(0),
                          hintText: AppLocalizations.of(context)!.addFriendshipSelectionEmpty,
                          onChanged: (value) {
                            setState(() {
                              _currentFriendshipFuture = _requestedFriendshipFuture();
                              _searchText = value;
                            });
                          },
                        ),
                      ),
                    ),
                    SliverToBoxAdapter(
                      // Generated by Copilot - Use SearchResultList widget
                      child: SearchResultList(
                        userSearchFuture: userSearchFuture, // Generated by Copilot
                        onRequest: _requestFriendship,
                        scaffoldMessengerKey: friendAddScaffoldMessengerKey,
                        searchText: _searchText,
                      ),
                    ),
                    SliverToBoxAdapter(
                      // Generated by Copilot - Use PendingRequestList widget
                      child: PendingRequestList(
                        userPendingFuture: userPendingFuture, // Generated by Copilot
                        onAccept: _acceptFriendship,
                        onDecline: _declineFriendship,
                        scaffoldMessengerKey: friendAddScaffoldMessengerKey,
                      ),
                    ),
                    SliverToBoxAdapter(
                      // Generated by Copilot - Use ContactSuggestionList widget
                      child: ContactSuggestionList(
                        userContactFuture: userContactFuture, // Generated by Copilot
                        onRequest: _requestFriendship,
                        scaffoldMessengerKey: friendAddScaffoldMessengerKey,
                      ),
                    ),
                    SliverToBoxAdapter(
                      child: RequestedFriendshipList(
                        userRequestedFuture: userRequestedFuture,
                        onCancel: _cancelFriendRequest,
                        scaffoldMessengerKey: friendAddScaffoldMessengerKey,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  // Generated by Copilot - Function to fetch user search results
  Future<List<User>> _fetchUserSearchResults() async {
    if (_searchText.isEmpty) {
      return List.empty(growable: true);
    }

    final friendship = await _currentFriendshipFuture;

    List<String> selectedUsers = List.empty(growable: true);
    for (var friendship in friendship) {
      selectedUsers.add(friendship.user.email);
    }
    selectedUsers.add(supabase.auth.currentUser?.email ?? '');

    return await User.fetchData(_searchText, selectedUsers, 5);
  }

  // Generated by Copilot - Function to fetch pending friend requests
  Future<List<Map<String, dynamic>>> _fetchPendingFriendRequests() async {
    return supabase
        .from('friendship')
        .select('...requester(*)')
        .eq('addressee', supabase.auth.currentUser?.email ?? '')
        .eq('status', 'pending')
        .ilike('requester.display_name', '%$_searchText%')
        .order('display_name', ascending: false, referencedTable: 'requester');
  }

  // Generated by Copilot - Function to fetch contact suggestions using compute and caching
  Future<List<User>> _fetchContactSuggestions() async {
    // Generated by Copilot
    // Check cache first
    if (_cachedContacts == null) {
      if (!await fc.FlutterContacts.requestPermission()) {
        return []; // Return empty list if permission is denied
      }
      // Fetch contacts only if cache is empty and permission granted
      _cachedContacts =
          await fc.FlutterContacts.getContacts(withProperties: true, withPhoto: false); // Generated by Copilot
    }

    // If contacts are still null (e.g., error during fetch), return empty
    if (_cachedContacts == null) {
      return []; // Generated by Copilot
    }

    // Fetch friendships and build selected users list (async)
    final friendship = await _currentFriendshipFuture;
    List<String> selectedUsers = friendship.map((f) => f.user.email).toList(); // Generated by Copilot
    selectedUsers.add(supabase.auth.currentUser?.email ?? '');

    // Fetch all available users matching the search text (async)
    final allAvailableUser = await User.fetchData("%$_searchText%", selectedUsers, null); // Generated by Copilot
    final availableUserMap = {for (var user in allAvailableUser) user.email.toLowerCase(): user};

    // Prepare parameters for the isolate function using cached contacts
    final params = {
      'contacts': _cachedContacts!, // Use cached contacts, assert non-null // Generated by Copilot
      'availableUserMap': availableUserMap,
      'searchText': _searchText,
    };

    // Run the contact matching logic in a separate isolate
    return compute(_findContactMatches, params); // Generated by Copilot
  }

  Future<List<User>> _fetchRequestedUsers() async {
    final friendship = await _currentFriendshipFuture;

    List<User> requestedUsers = List.empty(growable: true);
    for (var friendship in friendship) {
      if (friendship.status == 'pending' && friendship.isRequester == false) {
        requestedUsers.add(friendship.user);
      }
    }

    return requestedUsers;
  }

  void _cancelFriendRequest(String userEmail, String displayName) async {
    await Friendship.cancel(userEmail).then((_) {
      showSnackBar(
          context, friendAddScaffoldMessengerKey, AppLocalizations.of(context)!.friendshipRequestCancel(displayName));

      setState(() {
        _currentFriendshipFuture = _requestedFriendshipFuture();
      });
    });
  }

  // Generated by Copilot - Callback for requesting friendship
  void _requestFriendship(String userEmail, String displayName) async {
    Friendship.request(userEmail).then((_) {
      showSnackBar(
          context, friendAddScaffoldMessengerKey, AppLocalizations.of(context)!.friendshipRequestSent(displayName));
      sendFriendRequestNotification(context, {userEmail});
      setState(() {
        _currentFriendshipFuture = _requestedFriendshipFuture();
      });
    });
  }

  // Generated by Copilot - Callback for accepting friendship
  void _acceptFriendship(String userEmail, String displayName) {
    Friendship.accepted(userEmail).then((_) {
      showSnackBar(context, friendAddScaffoldMessengerKey, AppLocalizations.of(context)!.friendshipAccept(displayName));
      sendFriendAcceptNotification(context, {userEmail});
      setState(() {
        _currentFriendshipFuture = _requestedFriendshipFuture();
      });
    });
  }

  // Generated by Copilot - Callback for declining friendship
  void _declineFriendship(String userEmail, String displayName) {
    Friendship.decline(userEmail).then((_) {
      showSnackBar(
          context, friendAddScaffoldMessengerKey, AppLocalizations.of(context)!.friendshipRequestDecline(displayName));
      setState(() {
        _currentFriendshipFuture = _requestedFriendshipFuture();
      });
    });
  }
}
